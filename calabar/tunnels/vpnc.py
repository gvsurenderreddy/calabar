from __future__ import with_statement

import csv
import os
import stat
from hashlib import md5

from calabar.tunnels import TUN_TYPE_STR
from calabar.tunnels.base import TunnelBase, TunnelTypeDoesNotMatch

class VpncTunnel(TunnelBase):
    """
    A `vpnc`_ tunnel.

    Create a new vpnc tunnel using the given vpn configuration file.

    ``conf_file`` is the path to the ``vpnc`` configuration file that will be
    used to make the connection
    ``executable`` is the path to the ``vpnc`` command

    .. _`vpnc`: http://www.unix-ag.uni-kl.de/~massar/vpnc/
    """
    TUNNEL_TYPE = 'vpnc'
    PROC_NAME = 'calabar_vpnc'
    EXEC = '/usr/sbin/vpnc'

    def __init__(self, conf_file, executable=None, ips=None, tunnel_type=None,
                 *args, **kwargs):
        self.conf_file = conf_file
        self._tun_script = None # Init the cached version of the s/t script
        self._tun_script_f = None # Init the cached version of the s/t script
        if ips == None:
            ips = []

        cmd = self._build_cmd(self.conf_file, ips)
        if not executable:
            executable = VpncTunnel.EXEC

        if tunnel_type and tunnel_type != VpncTunnel.TUNNEL_TYPE:
            raise TunnelTypeDoesNotMatch(
                'Tunnel type <%s> does not match expected <%s>' % (tunnel_type, TunnelBase.TUNNEL_TYPE))

        super(VpncTunnel, self).__init__(cmd, executable, *args, **kwargs)

    def _build_cmd(self, conf_file, ips):
        """
        Build the command that subprocess will execute in order to start the
        vpnc tunnel process.

        Command is in the format [<proccess_display_name>, <arg>...]
        """
        cmd = [VpncTunnel.PROC_NAME, conf_file]

        script_file = self.get_split_tunnel_script_fp(ips)
        script = ['--script', script_file]

        stay_in_foreground = ['--no-detach']
        random_port = ['--local-port', '0']
        non_interactive = ['--non-inter']

        cmd += stay_in_foreground + random_port + non_interactive + script

        return cmd

    def get_split_tunnel_script_fp(self, ips=None):
        """
        Get the path to the split-tunneling configuration script.

        ``ips`` is an array of IP addresses that will be the target of
        split tunneling
        """
        if not self._tun_script_f:
            if ips == None:
                ips = []
            self._set_split_tunnel_script_file(ips)

        return self._tun_script_f

    def _gen_script_fname(self, ips):
        ip_hash = md5("".join(ips).encode('utf-8')).hexdigest()[:12]
        fpath = os.path.join('/tmp/', ip_hash)

        return fpath

    def _set_split_tunnel_script_file(self, ips):
        contents = self._build_split_tunnel_script(ips)

        fpath = self._gen_script_fname(ips)
        with open(fpath, 'w') as tun_script:
            self._tun_script_f = fpath
            tun_script.write(contents)
        os.chmod(self._tun_script_f, stat.S_IXUSR | stat.S_IWUSR | stat.S_IRUSR)

        return self._tun_script_f

    def _build_split_tunnel_script(self, ips):
        """
        Build the vpnc script for split-tunneling to only the specific ip
        addresses and return the contents.

        ``ips`` is an array of IP addresses that will be the target of
        split-tunneling
        """
        if self._tun_script:
            return self._tun_script

        additional_ips = []
        for ip in ips:
            additional_ips.append(ADD_IP_TPL % {'ip':ip})

        self._tun_script = SPLIT_TUN_TPL % {'tun_ips': '\n'.join(additional_ips)}

        return self._tun_script

    @staticmethod
    def parse_configuration(config, section_name):
        """
        Parse out the required tunnel information from the given
        :mod:ConfigParser.ConfigParser instance, with this tunnel being
        represented by the tunnel at ``section_name``.

        Returns a dictionary with options corresponding to those taken by
        :member:`__init__`
        """
        tun_conf_d = {} # Tunnel configuration directory
        tun_conf_d[TUN_TYPE_STR] = VpncTunnel.TUNNEL_TYPE
        tun_conf_d['conf_file'] = config.get(section_name, 'conf_file')

        # Optional parts
        tun_conf_d['ips'] = []
        if config.has_option(section_name, 'ips'):
            ip_str = config.get(section_name, 'ips')
            tun_conf_d['ips'] = [itm.strip() for itm in csv.reader([ip_str]).next()]

        # Get the binary/executable for VPNC
        tun_conf_d['executable'] = None
        if config.has_option(VpncTunnel.TUNNEL_TYPE, 'bin'):
            tun_conf_d['executable'] = config.get(VpncTunnel.TUNNEL_TYPE, 'bin')

        return tun_conf_d

ADD_IP_TPL = "add_ip %(ip)s # auto-generated by calabar"
SPLIT_TUN_TPL = """#!/bin/sh

# Add one IP to the list of split tunnels
add_ip ()
{
        export CISCO_SPLIT_INC_${CISCO_SPLIT_INC}_ADDR=$1
        export CISCO_SPLIT_INC_${CISCO_SPLIT_INC}_MASK=255.255.255.255
        export CISCO_SPLIT_INC_${CISCO_SPLIT_INC}_MASKLEN=32
        export CISCO_SPLIT_INC=$(($CISCO_SPLIT_INC + 1))
}

# Initialize empty split tunnel list
export CISCO_SPLIT_INC=0

# Delete DNS info provided by VPN server to use internet DNS
# Comment following line to use DNS beyond VPN tunnel
unset INTERNAL_IP4_DNS

# List of IPs beyond VPN tunnel
%(tun_ips)s

# Execute default script
. /etc/vpnc/vpnc-script

# End of script
"""